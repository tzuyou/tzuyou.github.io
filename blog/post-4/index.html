<!DOCTYPE html>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<meta name="google-site-verification" content="DHnDdraLc8kIZkHLv82SyzLDgKAhiVbeoYqNtB6Z860" />
<meta http-equiv="Permissions-Policy" content="interest-cohort=()">
<html lang="zh-tw"><head>
    
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-H0NJQPGVHD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-H0NJQPGVHD');
  </script>
  <meta charset="utf-8">
  <title>Yogurt&#39;s blog</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="內容為學習所記筆記，省略些許東西，僅供參考">
  <meta name="author" content="Yogurt">
    
  
  <meta name="theme-name" content="liva-hugo" />
  
  <meta name="generator" content="Hugo 0.111.3">

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://tzuyou.github.io/plugins/bootstrap/bootstrap.min.css ">
  
  <link rel="stylesheet" href="https://tzuyou.github.io/plugins/slick/slick.css ">
  
  <link rel="stylesheet" href="https://tzuyou.github.io/plugins/themify-icons/themify-icons.css ">
  
  <link rel="stylesheet" href="https://tzuyou.github.io/plugins/venobox/venobox.css ">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://tzuyou.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://tzuyou.github.io/images/favicon.png " type="image/x-icon">
  <link rel="icon" href="https://tzuyou.github.io/images/favicon.png " type="image/x-icon">

  

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5NX8PV6KMH"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5NX8PV6KMH');
  </script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        tags: 'ams'
      },
      svg: { scale: 1.12, fontCache: 'global' }   
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <link rel="stylesheet" href="/css/mathjax-fix.css">
  



  

</head>
<body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->
<!-- navigation -->
<header class="navigation">
  <div class="container">
    
    <nav class="navbar navbar-expand-lg navbar-white bg-transparent border-bottom pl-0">
      <a class="navbar-brand mobile-view" href="https://tzuyou.github.io"><img class="img-fluid"
          src="https://tzuyou.github.io/images/logo.png" alt="Yogurt&#39;s blog"></a>
      <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation">
        <i class="ti-menu"></i>
      </button>

      <div class="collapse navbar-collapse text-center" id="navigation">
        <div class="desktop-view">
          <ul class="navbar-nav mr-auto">
            
            
            
            </li>
            
            
            
            </li>
            
          </ul>
        </div>

        <a class="navbar-brand mr-auto desktop-view" href="https://tzuyou.github.io"><img class="img-fluid"
            src="https://tzuyou.github.io/images/logo.png" alt="Yogurt&#39;s blog"></a>

        <ul class="navbar-nav">
          
          
          <li class="nav-item">
            <a class="nav-link" href="https://tzuyou.github.io/about/">About</a>
          </li>
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="https://tzuyou.github.io/">Home</a>
          </li>
          
          
          
        </ul>

        
        <!-- search -->
        <div class="search pl-lg-4">
          <button id="searchOpen" class="search-btn"><i class="ti-search"></i></button>
          <div class="search-wrapper">
            <form action="https://tzuyou.github.io/search" class="h-100">
              <input class="search-box px-4" id="search-query" name="s" type="search" placeholder="Type & Hit Enter...">
            </form>
            <button id="searchClose" class="search-close"><i class="ti-close text-dark"></i></button>
          </div>
        </div>
        

        
      </div>
    </nav>
  </div>
</header>
<!-- /navigation -->

<section class="section-sm">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 mx-auto">
        
        <a href="/categories/%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88"
          class="text-primary">程式設計</a>
        
        <h2>C/C++程式語言_基礎篇</h2>
        <div class="mb-3 post-meta">
          <span>By Yogurt</span>
          
          <span class="border-bottom border-primary px-2 mx-1"></span>
          <span>08 February 2024</span>
          
        </div>
        
        <div class="content mb-5">
          <h3 id="零---補充">零&mdash;補充</h3>
<h4 id="一基本運算子">一、基本運算子</h4>
<ol>
<li>邏輯</li>
</ol>
<p>運算符號： + - * / %(取餘數)</p>
<ul>
<li>優化c++</li>
<li><code>ios::sync_with_stdio(false), cin.tie(nullptr);</code></li>
<li>前者解除同步；後者輸出終端改成全輸入後再一次輸出。</li>
</ul>
<table>
<thead>
<tr>
<th>運算子</th>
<th>意義</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>AND,且</td>
</tr>
<tr>
<td>||</td>
<td>OR,或</td>
</tr>
<tr>
<td>!</td>
<td>NOT,否</td>
</tr>
</tbody>
</table>
<h4 id="二其他常用的運算子">二、其他常用的運算子</h4>
<ol>
<li>增遞/減遞運算</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">運算子</th>
<th style="text-align:center">意義</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">變數值加 1</td>
</tr>
<tr>
<td style="text-align:center">- -</td>
<td style="text-align:center">變數值減 1</td>
</tr>
</tbody>
</table>
<ul>
<li>i++：先執行整個敘述後, 再將 i 的值加 1</li>
<li>++i：先將 i 的值加 1, 再執行整個敘述</li>
<li>特別的在for迴圈中，第三區塊是等所有程式執行完才進行。
因此i++跟 ++i沒有太多差別(無運算式) 差在是否複製舊副本與回傳值，於int影響甚小。
2.</li>
</ul>
<table>
<thead>
<tr>
<th>運算子(?:)</th>
<th>意義</th>
</tr>
</thead>
<tbody>
<tr>
<td>條件判斷 ? 運算式 1 : 運算式 2</td>
<td></td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>if(判斷條件)
運算式 1;
else
運算式 2;
</code></pre><table>
<thead>
<tr>
<th>實例1</th>
<th>實例2</th>
</tr>
</thead>
<tbody>
<tr>
<td>a = (x &gt; 100) ? b : c;</td>
<td>abs = (a &gt; 0) ? a : -a;</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>if (a &gt; 0)
 abs = a;
else
 abs = -a; 
</code></pre><hr>
<h3 id="壹格式化的輸入與輸出">壹、格式化的輸入與輸出</h3>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;#將檔案&lt;stdio.h&gt;將進來
int main(){
    printf(&#34;Hello world!&#34;);
    return 0;
}
</code></pre><p><a href="https://">https://web.fg.tp.edu.tw/~earth/vision/study/cprogram06/C_handout.pdf</a></p>
<h4 id="一標準輸出指令">一、標準輸出指令</h4>
<p><code>printf(&quot;格式字串&quot;, N1, N2,...);</code></p>
<p><code>scanf(&quot;格式字串&quot;,&amp;N1,&amp;N2,...);</code></p>
<h5 id="printf">Printf</h5>
<pre tabindex="0"><code>int main(){
	int a = 1 ;
	printf(&#34;Hello \n%d&#34;, a);
	return 0; 
} 
</code></pre><h5 id="scanf">Scanf</h5>
<pre tabindex="0"><code>int main(){
	int a,b;
	scanf(&#34;%d%d&#34;,&amp;a,&amp;b);
	printf(&#34;%d,%d&#34;,a,b);
}
</code></pre><ul>
<li>注意!如果要讀取字元陣列時，<code>str</code>它被當作指向字串的指標使用，所以在 scanf 函式中，我們直接使用陣列名稱 str 來讀取字串。因為 str 已經是一個指向陣列的指標，使用 &amp; 運算子會導致類型不匹配</li>
</ul>
<blockquote>
<p>字串為字元的陣列</p>
</blockquote>
<h4 id="二跳脫字元escape-sequence">二、跳脫字元(Escape Sequence)</h4>
<table>
<thead>
<tr>
<th>\n 換行</th>
<th>\&quot; 雙引號</th>
<th>\&rsquo; 單引號</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>\f 換頁</td>
<td>\t 跳格</td>
<td>\b 倒退</td>
<td></td>
</tr>
<tr>
<td>\x ASCII 碼 (16 進位)</td>
<td>\d ASCII 碼 (8 進位)</td>
<td>\\ 反斜線</td>
<td>\/ 斜線</td>
</tr>
</tbody>
</table>
<p><strong>例子 執行結果</strong></p>
<pre tabindex="0"><code>printf(&#34;\tThis line begins with tab.\n&#34;);
printf(&#34;It\&#39;s a \&#34;C Tutorial\&#34;.\n&#34;);
printf(&#34;This is backslash: \\.\n&#34;);
printf(&#34;\\101 is \101.\n&#34;);
printf(&#34;\\x41 is \x41.\n&#34;);
</code></pre><blockquote>
<p>This line begins with tab.
It&rsquo;s a &ldquo;C Tutorial&rdquo;.
This is backslash: .
\101 is A.
\x41 is A.</p>
</blockquote>
<h4 id="三修飾子">三、修飾子</h4>
<table>
<thead>
<tr>
<th>-：向左靠齊</th>
<th>+：印出正負號</th>
<th>%c：字元</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s：字串     %d：十進位整數</td>
<td>%f：浮點數 (小數點型式)</td>
<td>%l：長整數，加在 d、u…之前</td>
</tr>
<tr>
<td>%u：無號十進位整數</td>
<td>%e：浮點數 (指數 e 型式)</td>
<td>Nope</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="貳流程控制">貳、流程控制</h3>
<h4 id="一if-指令">一、if 指令</h4>
<h5 id="巨集">巨集</h5>
<blockquote>
<p>define name 函式</p>
</blockquote>
<pre tabindex="0"><code>#define MAX(a, b) (a&gt;b ? a:b)
int main(){
	int x, y;
	printf(&#34;輸入N1:&#34;);
	scanf(&#34;%d&#34;,&amp;x);
	printf(&#34;輸入N2:&#34;);
	scanf(&#34;%d&#34;,&amp;y);
	printf(&#34;兩數最大值為:%d\n&#34;,MAX(x, y));
}
</code></pre><pre tabindex="0"><code>if (條件判斷式)
{
    指令1;
    ...2;
    ...3;
    .....
}
</code></pre><pre tabindex="0"><code></code></pre><h5 id="單一條件不用加">單一條件不用加</h5>
<pre tabindex="0"><code>if (條件判斷)
    指令1 ;
</code></pre><h5 id="all">ALL</h5>
<pre tabindex="0"><code>int main(){
	int a;
	printf(&#34;輸入成績:&#34;);
	scanf(&#34;%d&#34;,&amp;a);
	if (a&gt;=60 &amp;&amp; a&lt;=100)
		printf(&#34;及格\n&#34;);
	
	else if (a&gt;100)
		printf(&#34;error!\n&#34;);
	
	else
		printf(&#34;不及格\n&#34;);
}
</code></pre><h4 id="二switch指令">二、switch指令</h4>
<h5 id="casedefault">case、default</h5>
<hr>
<p><img src="https://hackmd.io/_uploads/HJSMQ-39h.png" alt=""></p>
<hr>
<p>範例題：</p>
<blockquote>
<p>依據下列表格中的等級表，使用switch完成分數的判斷，且在使用者輸入成績後顯示出等級</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">等第</th>
<th style="text-align:center">分數</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">90~100</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">80~90</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">70~79</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">60~69</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">0~59</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>switch (運算式)
{
     case 選擇值 1:
         敘述主體 1;
         break;
     case 選擇值 2:
         敘述主體 2;
         break;
     …
     case 選擇值 n:
         敘述主體 n;
         break;
     default:
         敘述主體;
} 
</code></pre><p>Answer:</p>
<pre tabindex="0"><code>int main(){
	int a;
	
	printf(&#34;輸入成績:&#34;);
	scanf(&#34;%d&#34;,&amp;a);
	
	switch ( a/10 ){
		case 10:
            printf(&#34;A&#34;);
            break;
		case 9:
			printf(&#34;A&#34;);
			break;
		case 8:
			printf(&#34;B&#34;);
			break;
		case 7:
			printf(&#34;C&#34;);
			break;
		case 6:
			printf(&#34;D&#34;);
			break;
		case 0 ... 5:  /* gcc擴充套件允許對比特定範圍 (0~5)*\
			printf(&#34;E&#34;);
			break;
	}
}
</code></pre><h5 id="for-迴圈">for 迴圈</h5>
<pre tabindex="0"><code>for(變數起始1;條件;變數增減){

    程式1;

    for(變數起始2;條件;變數增減){
    
        程式2;
    }

}
</code></pre><h5 id="while">while</h5>
<pre tabindex="0"><code>while(條件判斷){

    程式區;

}
</code></pre><h5 id="do-while-後測試型迴圈">do-while (後測試型迴圈)</h5>
<blockquote>
<p>do裡的程式碼會被先執行一次</p>
</blockquote>
<pre tabindex="0"><code>do{

    :
    程式區;

}
    while(條件判斷);
</code></pre><h5 id="breakcontinue">break、continue</h5>
<ul>
<li>break跳脫迴圈不再執行下列程式</li>
<li>continue持續執行迴圈並跳過下列程式</li>
</ul>
<h3 id="參陣列字串矩陣結構與檔案">參、陣列、字串、矩陣、結構與檔案</h3>
<h4 id="一陣列">一、陣列</h4>
<h5 id="一維">一維</h5>
<ul>
<li>元素個數可未設定(自動)</li>
<li>超過個數長度時將自動設定為0</li>
</ul>
<pre tabindex="0"><code>int arr[] = {
    [0] = 3,
    [1] = 4,
    [2] = 5,
    [3] = 6,
    [4] = 7,
};
</code></pre><pre tabindex="0"><code>資料型態 陣列名稱 [長度];
</code></pre><p>或者</p>
<pre tabindex="0"><code>資料型態 陣列名稱 [大小]={初始值1,..2,..3,...};
</code></pre><h5 id="二維">二維</h5>
<ul>
<li>若初始值個數少於設定長度其餘將設定為0</li>
<li>c/c++以列為主軸</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">行[0]</th>
<th style="text-align:center">行[1]</th>
<th style="text-align:center">行[2]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">列[0]</td>
<td style="text-align:center">[0][0]</td>
<td style="text-align:center">[0][1]</td>
<td style="text-align:center">[0][2]</td>
</tr>
<tr>
<td style="text-align:center">列[1]</td>
<td style="text-align:center">[1][0]</td>
<td style="text-align:center">[1][1]</td>
<td style="text-align:center">[1][2]</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>資料型態 陣列名稱 [列個數] [行個數];
</code></pre><pre tabindex="0"><code>資料型態 陣列名稱 [列個數] [行個數] ={{var1,var2,var3},{var4,var5,var6}};
</code></pre><h4 id="二結構">二、結構</h4>
<h5 id="struct">struct</h5>
<pre tabindex="0"><code>struct 結構名稱
{
    資料型態 成員1;
    資料型態 成員2;
    ......

}s1,s2;
</code></pre><ul>
<li>定義結構變數</li>
</ul>
<p><code>struct name s1,s2;</code></p>
<ul>
<li>點運算子(用於存取)</li>
</ul>
<p><code>結構變數.成員名稱;</code></p>
<ul>
<li>成績&amp;名子</li>
</ul>
<pre tabindex="0"><code>int main(){
	struct rank
	{
		char name[10];
		int score;

	} s1,s2 ;
	
	strcpy(s1.name,&#34;KATE&#34;);
	s1.score = 900;
	s2 = s1;
	printf(&#34;%s%d&#34;,s2.name,s2.score);
	return 0;
}
</code></pre><h5 id="巢狀struct">巢狀struct</h5>
<pre tabindex="0"><code>struct 結構名稱1
{
    資料型態 成員1;
    資料型態 成員2;
    ......

};
struct 結構名稱2
{
    
    ......
    struct 結構名稱1 變數名稱;

};
</code></pre><h5 id="結構陣列">結構陣列</h5>
<ul>
<li>宣告</li>
</ul>
<p><code>struct 結構名稱 陣列名稱 [長度];</code></p>
<ul>
<li>存取</li>
</ul>
<p><code>陣列名稱 [索引值].陣列成員名稱</code></p>
<pre tabindex="0"><code>struct 結構名稱
{
    
    ......
    資料型態 陣列名稱 [個數];

};
</code></pre><p><code>struct 結構名稱 陣列名稱 [個數];</code></p>
<ul>
<li>存取</li>
</ul>
<p><code>陣列名稱 [索引值].陣列成員名稱[索引值]</code></p>
<ul>
<li>下圖為建立5個元素的結構陣列</li>
</ul>
<pre tabindex="0"><code>struct student
{
    char name[10];
    int score;

};
struct student class1[5];
</code></pre><h3 id="容器-vectormapqueuestack">容器 vector、map、queue、stack</h3>
<h4 id="map-vs-unorder_map">map vs unorder_map</h4>
<h5 id="map">map</h5>
<p>基礎建立於樹狀(紅黑樹)存取資料，遍歷時會自動排序好鍵(key)，因此在查找與插入為O(log n)。
適合用在大於某個值得最小key等或是區間查詢。</p>
<ul>
<li>find() 找尋某個值，回傳該值。</li>
<li>map-&gt;second 回傳鍵值。</li>
<li>count() 回傳元素有幾個。</li>
</ul>
<h5 id="unorder_map">unorder_map</h5>
<p>基礎建立於雜湊&amp;&amp;沒有順序之差。因此在查找與插入為O(1)，但需要消耗較多記憶體空間。
適合使用大量查詢判斷是否有該值存在、以及鍵值為何。
Key 數量大則很適用使用。</p>
<ul>
<li>使用at()如果不存在，會直接out of range;</li>
<li>如果發生碰撞問題會退化O (n)</li>
<li>不允許重複元素</li>
<li>reserve可避免rehash問題，影響執行效率。</li>
</ul>
<h5 id="vector">vector</h5>
<p>動態的容器，每次push_back()、insert，都會重新分配記憶體。</p>
<ul>
<li>reserve()分配記憶體。</li>
<li>assign(n,value)，重構並指定數值。
<code>visited.assign(n+1, vector&lt;bool&gt;(m+1, false));</code>(二維靜態)
<code>vector&lt;vector&lt;int&gt;&gt; v(n);</code>(二維動態)</li>
<li>push_back()放入尾端</li>
<li>size()陣列元素的總數</li>
<li>begin()指著第一個元素，end()指著最後元素的下一個
it++ 會保留舊副本; ++ it 則會直接下一個，在map等效率很重視++it</li>
<li>empty()回傳是否為空，true or false</li>
</ul>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">for(auto it = v.begin(); it!= v.end();++it){
        cout&lt;&lt;*it&lt;&lt;&#39; &#39;;
    }
</code></pre><h3 id="各種有用的-autoautostring">各種有用的 (auto、auto&amp;、string&hellip;)</h3>
<h4 id="autoauto">auto、auto&amp;</h4>
<p>auto用於複製一份資料。可iterate nums陣列。</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">nums[4]={0,1,2,3,4};
for(auto x:nums){
    x=0;
}
//nums-&gt;0 1 2 3 4
</code></pre><p>auto&amp; 直接修改值本身</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">nums[4]={0,1,2,3,4};
for(auto &amp;x:nums){
    x=0;
}
//nums-&gt;0 0 0 0 0
</code></pre><h4 id="string">string</h4>
<p><code>string +=</code>：添加字串<br>
<code>string+</code>：字串相加<br>
<code>at(i)</code>：存取索引值[i]的字元，存取越界會拋出一個例外<br>
<code>find()</code>：字串搜尋，回傳字串首個位置。
<code>substr(n,m)</code>：取得子字串，從n開始往印出m個字母。
<code>empty()</code>：回傳是否為空，空則回傳true<br>
<code>size()</code>：回傳目前長度<br>
<code>length()</code>：回傳目前長度
<code>append()</code>：添加字串</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">for (auto &amp;c : str) {  
        cout &lt;&lt; c &lt;&lt; &#39;\n&#39;;  
    }
}
</code></pre><p>取得str的地址開始疊代。</p>
<ul>
<li>如果使用運算式相加會複製一份，可以使用append or += 提升效率</li>
</ul>
<h4 id="rotate">rotate</h4>
<p>將陣列元素往後位移n個，中間begin使前方往後n個元素;反之end使後方往前n個元素。
<code>rotate(v.begin(),v.begin/end(),n)</code> ;<code>#inlcude&lt;algorithm&gt;</code></p>
<h4 id="sort-vs-qsort函式">sort vs qsort函式</h4>
<p>結論是c++ stl sort一定比c的qsort快
以下為使用方法</p>
<h5 id="sort">sort</h5>
<p>一般陣列 : sort(a,b) 指從a位置排到b位置 ,大到小則在sort(a,b,cmp) cmp中加入 <code>greater&lt;int&gt;()</code></p>
<p>vector : sort(v.begin(),v.begin()+n) 也為相同道理，只是stl容器需要使用begin()+n來指定起終點。大到小同理<code>greater&lt;int&gt;()</code> 或是善用反向迭代 <code>sort(v.rbegin(),v.rend())</code></p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(void) {
    int v[6]={2,7,3,1,4,5};
    vector&lt;int&gt; v2={2,7,3,1,4,5};
    sort(v,v+6); sort(v2.begin(),v2.end());
    for(int i=0;i&lt;6;i++) {
        cout&lt;&lt;v[i]&lt;&lt;&#34; &#34;;
    }
    cout&lt;&lt;&#34;\n&#34;;
    for(int i=0;i&lt;6;i++) {
        cout&lt;&lt;v2[i]&lt;&lt;&#34; &#34;;
    }
    cout&lt;&lt;&#34;\n&#34;;
}
</code></pre><p>struct : 多加一個比較函式，看要針對結構哪個排序。 a.score &lt; b.score 回傳true 表示每個a&lt;b，由小到大排，反之大到小。</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
struct node {
    string name;
    int score;
}s[3];
bool cmp(node a,node b) {
    return a.score &lt; b.score;
}
int main(void) {
    s[0].name=&#34;Ken&#34;;s[0].score=70;
    s[1].name=&#34;Yellow&#34;;s[1].score=50;
    s[2].name=&#34;Green&#34;;s[2].score=60;
    for(auto st: s) {
        cout&lt;&lt;st.name&lt;&lt;&#34; score:&#34;&lt;&lt;st.score&lt;&lt;endl;
    }
    sort(s,s+3,cmp);
    for(auto st: s) {
        cout&lt;&lt;st.name&lt;&lt;&#34; score:&#34;&lt;&lt;st.score&lt;&lt;endl;
    }
}
</code></pre><h5 id="qsort">qsort</h5>
<p>一般陣列： qsort(陣列，數量，記憶體形式，比較函式)。 指向int指向a，a-b為小到大， b-a為大到小。</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">#include &lt;iostream&gt;
using namespace std;
int cmp(const void* a,const void* b) {
    return (*(int *)a) - (*(int *)b);
}
int main(void) {
    int v[5]={3,4,2,1,5};
    for(auto st: v) {
        cout&lt;&lt;st&lt;&lt;&#34; &#34;;
    }
    cout&lt;&lt;endl;
    qsort(v,5,sizeof(int),cmp);
    for(auto st: v) {
        cout&lt;&lt;st&lt;&lt;&#34; &#34;;
    }
}
</code></pre><p>struct : cmp中由int位置改成 struct node(結構名稱)。意思為struct node 指向 a 指向score， a-b為小到大， b-a為大到小。</p>
<pre tabindex="0"><code class="language-cpp!" data-lang="cpp!">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
    string name;
    int score;
}s[3];
int cmp(const void* a,const void* b) {
    return ((struct node *)a)-&gt;score - ((struct node *)b)-&gt;score;
}
int main(void) {
    s[0].name=&#34;Ken&#34;;s[0].score=70;
    s[1].name=&#34;Yellow&#34;;s[1].score=50;
    s[2].name=&#34;Green&#34;;s[2].score=60;
    for(auto st: s) {
        cout&lt;&lt;st.name&lt;&lt;&#34; score:&#34;&lt;&lt;st.score&lt;&lt;endl;
    }
    qsort(s,3,sizeof(struct node),cmp);
    for(auto st: s) {
        cout&lt;&lt;st.name&lt;&lt;&#34; score:&#34;&lt;&lt;st.score&lt;&lt;endl;
    }
}
</code></pre>
        </div>
        <script src="https://utteranc.es/client.js"
          repo="tzuyou/tzuyou.github.io"
          issue-term="title"
          theme="github-light"
          crossorigin="anonymous"
          async>
          </script>
        
        
        

      </div>
    </div>
  </div>
</section>





<script>
  var indexURL = "https://tzuyou.github.io/index.json"
</script>

<!-- JS Plugins -->

<script src="https://tzuyou.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://tzuyou.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://tzuyou.github.io/plugins/slick/slick.min.js"></script>

<script src="https://tzuyou.github.io/plugins/venobox/venobox.min.js"></script>

<script src="https://tzuyou.github.io/plugins/search/fuse.min.js"></script>

<script src="https://tzuyou.github.io/plugins/search/mark.js"></script>

<script src="https://tzuyou.github.io/plugins/search/search.js"></script>

<!-- Main Script -->

<script src="https://tzuyou.github.io/js/script.min.js"></script>




<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-sm btn-primary ml-2">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>

<div class="mySidenav">
    <a href="../index.html" class="home">Home</a>
    <a href="https://tzuyou.github.io/blog/post-1/" class="blog1">程式語言介紹</a>
    <a href="https://tzuyou.github.io/blog/post-2/" class="blog2">Markdown介紹</a>
    <a href="https://tzuyou.github.io/blog/post-3/" class="blog3">HTML簡易教學</a>
    <a href="https://tzuyou.github.io/blog/post-4/" class="blog4">C程式語言設計筆記</a>
    <a href="https://tzuyou.github.io/blog/post-5/" class="blog5">APCS題解</a>
</div>

<div id="container">
  <button class="openbtn" onclick="openNav()">&#9776; 選單</button>
  <div id="mySidepanel" class="sidepanel" style="overflow: hidden;">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    <a href="../index.html" id="home">Home</a>
    <a href="https://tzuyou.github.io/blog/post-1/" id="blog1">程式語言介紹</a>
    <a href="https://tzuyou.github.io/blog/post-2/" id="blog2">Markdown介紹</a>
    <a href="https://tzuyou.github.io/blog/post-3/" id="blog3">HTML簡易教學</a>
    <a href="https://tzuyou.github.io/blog/post-4/" id="blog4">C程式語言設計筆記</a>
    <a href="https://tzuyou.github.io/blog/post-5/" id="blog5">APCS題解</a>
  </div>
</div></body>
</html>