[{"categories":["程式設計"],"contents":"演算法 具有時效性，不會形成無窮迴圈，能夠解決問題的一道方法。\n分治演算法 將一個大問題拆解成許多的子問題 再由各子問題的解合併出答案\n1. 費伯納數列 直接遞迴 在遞迴函數中直接呼叫本身\nint Fun(...) { ... if(...) Fun(...) ... } 間接遞迴 在遞迴函數中呼叫其他遞迴，再從其他遞迴呼叫回遞迴函數。\nint Fun(...) { . if(...) Fun2(...) ... } int Fun2(...) { . if (...) Fun(...) ... } For example:\nn! =nX(n-1) * (n-2) .....*1 code\nint factorial(int i) { int sum; if (i==0) /*終結*\\ { return(1); } else { sum = i*factorial(i-1); /*sum =n*(n-1)*\\ } return sum; } For example2:\n第零項為0 第一項為1，每個項目皆由前兩項相加所得的數_費伯納序列(Fibonacci)。\ncode\nint fib(int n) { if (n==0) return 0; if (n==1) return 1; else return fib(n-1)+fib(n-2);/*呼叫兩次*/ } 2.河內塔問題 結論：\n步驟1: 將n-1盤子，從木樁1移到2 步驟2: 移動第n個最大的盤子，從木樁1移到3 步驟3: 將n-1盤子，從木樁2移到3\n限制:\n直徑較小套環永遠置於直徑較大的上方 套還可隨意從木樁移到其他木樁 每一次僅能移動一個套環，且為最上面開始移動 code:\n#include\u0026lt;stdio.h\u0026gt; void hanoi(int n, int p1, int p2, int p3) { if (n==1) /*出口*/ printf(\u0026#34;第%d個套環從 %d 移到 %d\\n\u0026#34;,n,p1,p3); else { hanoi(n-1,p1,p3,p2); printf(\u0026#34;第%d個套環從 %d 移到 %d\\n\u0026#34;,n,p1,p3); hanoi(n-1,p2,p1,p3); } } int main() { int n = 3; // 套環的數量 hanoi(n, 1, 2, 3); // 從柱子1移動到柱子3，使用柱子2作為中介 return 0; } 排序演算法 1.選擇排序 目的：找到數列中最小值往前排。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define N 10 /* run this program using the console pauser or add your own getch, system(\u0026#34;pause\u0026#34;) or input loop */ int data[N]; int main(void) { srand(time(NULL)); int i,j,k,p,tmp; for(i=0; i\u0026lt;N ; i++){ data[i] =rand()%100; } for(i=0; i\u0026lt;N ; i++){ printf(\u0026#34;%d \u0026#34;,data[i]); } k=0; for(j=0;j\u0026lt;N-1;j++) { for(i=j+1 ; i\u0026lt;N ; i++){ if(data[i]\u0026lt;data[k]) k=i; } tmp=data[j]; data[j]=data[k]; data[k]=tmp; } printf(\u0026#34;\\n\u0026#34;); for(i=0; i\u0026lt;N ; i++){ printf(\u0026#34;%d \u0026#34;,data[i]); } } 2.插入排序 目的：從頭開始，一直往前找做交換。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define N 10 int data[N]; int main(void) { srand(time(NULL)); int i,j,k,p,tmp; for(i=0; i\u0026lt;N ; i++){ data[i] =rand()%100; } for(i=0; i\u0026lt;N ; i++){ printf(\u0026#34;%3d \u0026#34;,data[i]); } printf(\u0026#34;\\n\u0026#34;); for(j=1;j\u0026lt;N;j++) { tmp=data[j]; for(i=j;i\u0026gt;0;i--){ if(data[i-1]\u0026gt;data[i]){ data[i] =data[i-1]; data[i-1]=tmp; } else break; } for(i=0; i\u0026lt;N ; i++){ printf(\u0026#34;%3d \u0026#34;,data[i]); } printf(\u0026#34;\\n\u0026#34;); } } 3.快速排序(quick sort) 核心：每次開始定一個虛擬值k(Pivot)，使數列切割點k的左側全部小於這個值，右側則大於這個值，最終就能抵達正確位置，再切割後兩邊繼續選k，如此循環便能由小到大排序。分割後數列繼續切割，不斷下去就能完成排序。\n屬於一個較不穩定的排序，若每次挑選中間值為最大或最小，會造成最壞情況 $$時間:O(n²)$$$$空間:O(n)$$\n最壞時變成單鏈深度為n，遞迴處理量:\n$$\\underbrace{n+(n-1)+\\cdots+1}_{\\frac {n\\times(n-1)}{2}}=O(n)\\rightarrow\\times O(n)= O(n^2)$$\n$$處理量乘上深度$$\n陣列大量重複元素或已經排序好的陣列選擇頭與尾會造成worse case\n較好以及平均而言為: $$時間:O(n\\times \\log_2n)、空間:O(\\log_2n)。$$\n題目：a104. 排序\n由於選擇位置+有大量重複元素，a233只得45%。\n程式碼：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; void quick_sort(vector\u0026lt;int\u0026gt; \u0026amp;nums,int ,int ); int partition_find(vector\u0026lt;int\u0026gt; \u0026amp;nums,int ,int); int partition_find(vector\u0026lt;int\u0026gt; \u0026amp;nums, int l, int r) { int privot = nums[l]; int i=l+1,j=r; while(i\u0026lt;=j){ if(nums[i]\u0026lt;privot){ i++; } else if(nums[j]\u0026gt;=privot){ j--; } else{ swap(nums[i],nums[j]); } } swap(nums[l], nums[j]); return j; } void quick_sort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int l, int r) { if (l \u0026lt; r) { int privot = partition_find(nums, l, r); quick_sort(nums, l, privot - 1); // left quick_sort(nums, privot + 1, r); // right } } int main(void){ int n; vector\u0026lt;int\u0026gt; nums; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF){ nums.clear(); int a; for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); nums.push_back(a); } quick_sort(nums,0,n-1); for(int i=0;i\u0026lt;n-1;i++){ printf(\u0026#34;%d \u0026#34;,nums[i]); } printf(\u0026#34;%d\u0026#34;,nums[n-1]); } } 4.合併排序(Merge sort) 核心：將數列拆解兩個兩個一組，排序後合併，再排序合併。 簡單來說分為拆分與合併兩步驟。\n拆分：\n把大數列切一半成為兩個數列 把切好的兩個數列再各自切一半 重複步驟2直到每個數列都只剩一個元素 合併：\n排序兩個只剩一個元素的數列並合併 把兩邊排序好的數列合併並排序成一個數列 重複步驟2直到所有數列都合併成一個完整數列 平均而言: $$總共要處理O(\\log_2n)，每次合併時間複雜度O(n)(排序部分)。因此O(n\\times\\log_2n)。 空間複雜度O(n)，需要另外的空間。$$\n題目：a233. 排序法~~~ 挑戰極限 程式碼：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; v; int data[1000000]; void merge_sort(int ,int ); void merge_sort(int L,int R){ if (L==R) return; //拆分 int M=(L+R)/2; merge_sort(L,M); merge_sort(M+1,R); //合併 int i=L,j=M+1,k=L; while(i\u0026lt;=M || j\u0026lt;=R){ if( j\u0026gt;R || (i\u0026lt;=M \u0026amp;\u0026amp; v[i]\u0026lt;v[j])){ data[k]=v[i]; i++; } else{ data[k]=v[j]; j++; } k++; } //記得複製成新的陣列 for(i=L;i\u0026lt;=R;i++){ v[i]=data[i]; } } int main(void){ cin.tie(0),cout.tie(0), ios::sync_with_stdio(false); int N,a; cin\u0026gt;\u0026gt;N; for(int i=0;i\u0026lt;N;i++) { cin\u0026gt;\u0026gt;a; v.push_back(a); } //merge sort merge_sort(0,N-1); for(int i=0;i\u0026lt;N-1;i++){ cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;v[N-1]; } 5.各類排序 做比較\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;string.h\u0026gt; int N; int data[1000000]; int test[1000000]; void bubble_sort(int,int);\t//氣泡排序 void selection_sort(int,int);\t//選擇排序 void merge_sort(int,int); void show_test();\t//顯示 test 陣列結果 int main(void){ printf(\u0026#34;請輸入要產生的數量(1000000以內)： \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;N); if(N\u0026gt;=2000000){ printf(\u0026#34;數量太大\u0026#34;);\treturn 0;\t} clock_t start_t;\tsrand(time(NULL)); int i,j,k,p,tmp;\tfor(i=0; i\u0026lt; N; i++)\tdata[i]=(rand()%30000)*(rand()%30000);\t//產生資料 for(i=0; i\u0026lt; N; i++)\ttest[i]=data[i];\t//恢復資料 start_t = clock();\t//開始計時 merge_sort(0,N-1);\t//排序ing... printf(\u0026#34;合併排序： %.3f\\n\u0026#34;, (double)(clock() - start_t) / CLOCKS_PER_SEC); for(i=0; i\u0026lt; N; i++)\ttest[i]=data[i];\t//恢復資料 start_t = clock();\t//開始計時 bubble_sort(0,N-1);\t//排序ing... printf(\u0026#34;氣泡排序： %.3f\\n\u0026#34;, (double)(clock() - start_t) / CLOCKS_PER_SEC); for(i=0; i\u0026lt; N; i++)\ttest[i]=data[i];\t//恢復資料 start_t = clock();\t//開始計時 selection_sort(0,N-1);\t//排序ing... printf(\u0026#34;選擇排序： %.3f\\n\u0026#34;, (double)(clock() - start_t) / CLOCKS_PER_SEC); } void show_test(){ int a; for(a=0;a\u0026lt;N;a++) printf(\u0026#34;%d \u0026#34;,test[a]);\tprintf(\u0026#34;\\n\u0026#34;); } void bubble_sort(int a,int b){ int i,j,k,tmp; for(i=b;i\u0026gt;0;i--){ for(j=1;j\u0026lt;=i;j++){ if(test[j-1]\u0026gt;test[j]){\ttmp=test[j-1],test[j-1]=test[j],test[j]=tmp;\t} } } } void selection_sort(int a,int b){ int i,j,k,tmp; for(i=a;i\u0026lt;=b;i++){\tk=i; for(j=i+1;j\u0026lt;=b;j++){ if(test[j]\u0026lt;test[k]){\tk=j;\t} } tmp=test[i],test[i]=test[k],test[k]=tmp; } } int result[1000000]; void merge_sort(int L, int R) { if(L==R) return; int M=(L+R)/2; merge_sort(L,M); merge_sort(M+1,R); int i=L,j=M+1,p=L; while(i\u0026lt;=M || j\u0026lt;=R) { if(j\u0026gt;R || (i\u0026lt;=M \u0026amp;\u0026amp; test[i]\u0026lt;test[j])) { result[p]=test[i]; i++; } else { result[p]=test[j]; j++; } p++; } for(i=L;i\u0026lt;=R;i++) { test[i]=result[i]; } } 6.基數演算法(Radix sort)[MDS+LSD] LSD 是從鍵值的最邊開始，所以適合位數小的資料來做排序。反之MDS從最左邊，也就是最高位數來開始排序。如果位數很多的話，MSD會來得更有效率一些。\nMDS 搜尋演算法 1.二分搜 核心：數列必須經過排序。並且左右邊界一個指著可能的答案；一個指著不可能的答案，每次搜尋從中間開始搜尋。當答案比搜尋出來的結果大，表示答案在右側，更新左邊界，反之更新右邊界，記住過程中仍要遵守左右邊界一個可能一個不可能(注意是否+1；或是在while中做判斷)\n$$時間複雜度：O(\\log_2n)，範圍\\log_2n\\sim \\log_2 (n+1)。$$\n題目：d732. 二分搜尋法 程式碼：\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(void){ int n,k; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); int i,a; vector\u0026lt;int\u0026gt; v; for(i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); v.push_back(a); } v.push_back(-1); for(i=0;i\u0026lt;k;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); int l=0,r=n; int ans=0; if (a\u0026gt;v[n-1] || a\u0026lt;=0){ printf(\u0026#34;%d\\n\u0026#34;,ans); continue; } while(l\u0026lt;r){ int mid=(r+l)/2; if(v[mid]==a){ ans=mid+1; break; } else if(v[mid]\u0026gt;a){ r=mid; } else if(v[mid]\u0026lt;a){ l=mid+1; } } printf(\u0026#34;%d\\n\u0026#34;,ans); } } 2.內插搜尋法 核心：二分搜改良版。預測資料時使用斜率+二分搜藉以逼近答案。因此資料越平均分布時間複雜度越小。 時間複雜度：平均優於 $O(log_2 n)$\n程式碼：\nint l=0,r=n-1,ans=0; while(l\u0026lt;=r){ int mid=l+((a-v[l])/(v[r]-v[l]))*(r-l); if(v[mid]==a){ ans=mid+1; break; } if(v[mid]\u0026gt;a){ r=mid-1; } else{ l=mid+1; } } printf(\u0026#34;%d\\n\u0026#34;,ans); 經典演算法 貪心 動態規劃(DP) 枚舉 質數求解 ","permalink":"https://tzuyou.github.io/blog/post-5/","tags":null,"title":"C++演算法(上)"},{"categories":["程式設計"],"contents":"目錄 APCS 2017-0304-2小群體 題目來源：c291. APCS 2017-0304-2小群體\n題目敘述：一群人在一起時經常會形成一個一個的小群體。假設有 N個人，編號由 0到 N-1，每個人都寫下他最好朋友的編號（最好朋友有可能是他自己的編號，如果他自己沒有其他好友）， 在本題中，每個人的好友編號絕對不會重複，也就是說0到 N-1每個數字 都恰好出現一次。\n輸入說明： 輸出說明： 第一行是一個正整數N，說明團體中人數。 第二行依序是 0的好友編號 、1的好友編號 、…… 、N-1的好友編號。共有N個數字，包含 0到 N-1的每個數字恰好出現一次，數字間會有一個空白隔開。 請輸出小群體的個數。 解題概念：可以從第編號0人開始追蹤他的好友一直追蹤下去直到迴圈結束，則為一個小群體。過程中可以分為兩個方法 1.使用迴圈 2.使用遞迴(DFS)。 兩者速度差不多，使用DFS可以幫助練習遞迴觀念。 方法1 (迴圈) :\n先開兩個陣列，friend[n] 用來存放每個編號的朋友，record[n] 則記錄哪些人已經被遍歷過。 接著先把編號0~N-1的朋友讀入陣列 friend[n] 。 最後我們要開始遍歷所有人，若這個人已被記錄過就continue，否則就把當前編號紀錄為k，然後小群體+1，並把當前的人記錄到record[n]裡面。然後使用無窮迴圈，將當前編號k的朋友陣列設成p變數 (int p = friends[k];)，並把p記錄在record裡。最重要的一步，我們要把k編號更新成原本k的朋友，而當新的k=i時則結束迴圈。如此即可得出答案。 程式碼如下： #include\u0026lt;stdio.h\u0026gt;\r#define n 50020\rint main(void)\r{\rint N,i,k=0,ans=0;\rint friends[n]={0};\rint record[n]={0};\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;N);\rfor(i=0;i\u0026lt;N;i++)\r{\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;friends[i]);\r}\rfor(i=0;i\u0026lt;N;i++)\r{\rif(record[i]==-1)\rcontinue;\relse\r{\rk=i;\rans++;\rrecord[i]=-1;\rwhile(1)\r{\rint p = friends[k];\rrecord[p]=-1;\rk = friends[k];\rif(k==i)\rbreak;\r}\r}\r}\rprintf(\u0026#34;%d\u0026#34;,ans);\r} 方法2 (遞迴) :\n步驟大致一樣，開兩陣列，然後再讀入。 開一迴圈如果當前被讀過就continue(以便不會一直dfs，節省時間)，否則群體+1，然後開始遞迴。 我們將編號 i (0~N-1) 輸進去遞迴裡，而每次遞迴的變數則是 now，也就是當前的編號。這邊可以設f=friend[now]; 增加可讀性，當 f=now (now跟now的朋友一樣) 就 return (結束遞迴)、如果當前編號被掃過也要 return，接者就可以開始記錄哪些已經遍歷，然後在函式內呼叫 dfs(f) 被傳入的值f為先前now的朋友，而重新一輪時的now就會更新成之前now的朋友 (有點饒口XD)。 程式碼如下： #include\u0026lt;stdio.h\u0026gt;\rint N;\rint friends[50005];\rint ans=0;\rint record[50005];\rvoid dfs(int now)\r{\rint f=friends[now];\rif(now==f) {\rreturn;\r}\rif(record[now]==-1) return;\rrecord[now]=-1;\rdfs(f);\r}\rint main(void)\r{\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;N);\rint i;\rfor(i=0;i\u0026lt;N;i++)\r{\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;friends[i]);\r}\rfor(i=0;i\u0026lt;N;i++)\r{\rif(record[i]==-1) {\rcontinue;\r}\relse\r{\rans++;\rdfs(i);\r}\r}\rprintf(\u0026#34;%d\u0026#34;,ans);\r} 總結來說：遞迴較為直觀，寫起來較為簡潔(當題目要求更多時)，但此題為實作第二，因此兩種皆可以用。\n","permalink":"https://tzuyou.github.io/blog/post-6/","tags":null,"title":"APCS題解"},{"categories":["程式設計"],"contents":"零\u0026mdash;補充 一、基本運算子 邏輯 運算符號： + - * / %(取餘數)\n優化c++ ios::sync_with_stdio(false), cin.tie(nullptr); 前者解除同步；後者輸出終端改成全輸入後再一次輸出。 運算子 意義 \u0026amp;\u0026amp; AND,且 || OR,或 ! NOT,否 二、其他常用的運算子 增遞/減遞運算 運算子 意義 ++ 變數值加 1 - - 變數值減 1 i++：先執行整個敘述後, 再將 i 的值加 1 ++i：先將 i 的值加 1, 再執行整個敘述 特別的在for迴圈中，第三區塊是等所有程式執行完才進行。 因此i++跟 ++i沒有太多差別(無運算式) 差在是否複製舊副本與回傳值，於int影響甚小。 2. 運算子(?:) 意義 條件判斷 ? 運算式 1 : 運算式 2 if(判斷條件)\r運算式 1;\relse\r運算式 2; 實例1 實例2 a = (x \u0026gt; 100) ? b : c; abs = (a \u0026gt; 0) ? a : -a; if (a \u0026gt; 0)\rabs = a;\relse\rabs = -a; 壹、格式化的輸入與輸出 #include \u0026lt;stdio.h\u0026gt;#將檔案\u0026lt;stdio.h\u0026gt;將進來\rint main(){\rprintf(\u0026#34;Hello world!\u0026#34;);\rreturn 0;\r} https://web.fg.tp.edu.tw/~earth/vision/study/cprogram06/C_handout.pdf\n一、標準輸出指令 printf(\u0026quot;格式字串\u0026quot;, N1, N2,...);\nscanf(\u0026quot;格式字串\u0026quot;,\u0026amp;N1,\u0026amp;N2,...);\nPrintf int main(){\rint a = 1 ;\rprintf(\u0026#34;Hello \\n%d\u0026#34;, a);\rreturn 0; } Scanf int main(){\rint a,b;\rscanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b);\rprintf(\u0026#34;%d,%d\u0026#34;,a,b);\r} 注意!如果要讀取字元陣列時，str它被當作指向字串的指標使用，所以在 scanf 函式中，我們直接使用陣列名稱 str 來讀取字串。因為 str 已經是一個指向陣列的指標，使用 \u0026amp; 運算子會導致類型不匹配 字串為字元的陣列\n二、跳脫字元(Escape Sequence) \\n 換行 \\\u0026quot; 雙引號 \\\u0026rsquo; 單引號 \\f 換頁 \\t 跳格 \\b 倒退 \\x ASCII 碼 (16 進位) \\d ASCII 碼 (8 進位) \\\\ 反斜線 \\/ 斜線 例子 執行結果\nprintf(\u0026#34;\\tThis line begins with tab.\\n\u0026#34;);\rprintf(\u0026#34;It\\\u0026#39;s a \\\u0026#34;C Tutorial\\\u0026#34;.\\n\u0026#34;);\rprintf(\u0026#34;This is backslash: \\\\.\\n\u0026#34;);\rprintf(\u0026#34;\\\\101 is \\101.\\n\u0026#34;);\rprintf(\u0026#34;\\\\x41 is \\x41.\\n\u0026#34;); This line begins with tab. It\u0026rsquo;s a \u0026ldquo;C Tutorial\u0026rdquo;. This is backslash: . \\101 is A. \\x41 is A.\n三、修飾子 -：向左靠齊 +：印出正負號 %c：字元 %s：字串 %d：十進位整數 %f：浮點數 (小數點型式) %l：長整數，加在 d、u…之前 %u：無號十進位整數 %e：浮點數 (指數 e 型式) Nope 貳、流程控制 一、if 指令 巨集 define name 函式\n#define MAX(a, b) (a\u0026gt;b ? a:b)\rint main(){\rint x, y;\rprintf(\u0026#34;輸入N1:\u0026#34;);\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;x);\rprintf(\u0026#34;輸入N2:\u0026#34;);\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;y);\rprintf(\u0026#34;兩數最大值為:%d\\n\u0026#34;,MAX(x, y));\r} if (條件判斷式)\r{\r指令1;\r...2;\r...3;\r.....\r} 單一條件不用加 if (條件判斷)\r指令1 ; ALL int main(){\rint a;\rprintf(\u0026#34;輸入成績:\u0026#34;);\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;a);\rif (a\u0026gt;=60 \u0026amp;\u0026amp; a\u0026lt;=100)\rprintf(\u0026#34;及格\\n\u0026#34;);\relse if (a\u0026gt;100)\rprintf(\u0026#34;error!\\n\u0026#34;);\relse\rprintf(\u0026#34;不及格\\n\u0026#34;);\r} 二、switch指令 case、default 範例題：\n依據下列表格中的等級表，使用switch完成分數的判斷，且在使用者輸入成績後顯示出等級\n等第 分數 A 90~100 B 80~90 C 70~79 D 60~69 E 0~59 switch (運算式)\r{\rcase 選擇值 1:\r敘述主體 1;\rbreak;\rcase 選擇值 2:\r敘述主體 2;\rbreak;\r…\rcase 選擇值 n:\r敘述主體 n;\rbreak;\rdefault:\r敘述主體;\r} Answer:\nint main(){\rint a;\rprintf(\u0026#34;輸入成績:\u0026#34;);\rscanf(\u0026#34;%d\u0026#34;,\u0026amp;a);\rswitch ( a/10 ){\rcase 10:\rprintf(\u0026#34;A\u0026#34;);\rbreak;\rcase 9:\rprintf(\u0026#34;A\u0026#34;);\rbreak;\rcase 8:\rprintf(\u0026#34;B\u0026#34;);\rbreak;\rcase 7:\rprintf(\u0026#34;C\u0026#34;);\rbreak;\rcase 6:\rprintf(\u0026#34;D\u0026#34;);\rbreak;\rcase 0 ... 5: /* gcc擴充套件允許對比特定範圍 (0~5)*\\\rprintf(\u0026#34;E\u0026#34;);\rbreak;\r}\r} for 迴圈 for(變數起始1;條件;變數增減){\r程式1;\rfor(變數起始2;條件;變數增減){\r程式2;\r}\r} while while(條件判斷){\r程式區;\r} do-while (後測試型迴圈) do裡的程式碼會被先執行一次\ndo{\r:\r程式區;\r}\rwhile(條件判斷); break、continue break跳脫迴圈不再執行下列程式 continue持續執行迴圈並跳過下列程式 參、陣列、字串、矩陣、結構與檔案 一、陣列 一維 元素個數可未設定(自動) 超過個數長度時將自動設定為0 int arr[] = {\r[0] = 3,\r[1] = 4,\r[2] = 5,\r[3] = 6,\r[4] = 7,\r}; 資料型態 陣列名稱 [長度]; 或者\n資料型態 陣列名稱 [大小]={初始值1,..2,..3,...}; 二維 若初始值個數少於設定長度其餘將設定為0 c/c++以列為主軸 x 行[0] 行[1] 行[2] 列[0] [0][0] [0][1] [0][2] 列[1] [1][0] [1][1] [1][2] 資料型態 陣列名稱 [列個數] [行個數]; 資料型態 陣列名稱 [列個數] [行個數] ={{var1,var2,var3},{var4,var5,var6}}; 二、結構 struct struct 結構名稱\r{\r資料型態 成員1;\r資料型態 成員2;\r......\r}s1,s2; 定義結構變數 struct name s1,s2;\n點運算子(用於存取) 結構變數.成員名稱;\n成績\u0026amp;名子 int main(){\rstruct rank\r{\rchar name[10];\rint score;\r} s1,s2 ;\rstrcpy(s1.name,\u0026#34;KATE\u0026#34;);\rs1.score = 900;\rs2 = s1;\rprintf(\u0026#34;%s%d\u0026#34;,s2.name,s2.score);\rreturn 0;\r} 巢狀struct struct 結構名稱1\r{\r資料型態 成員1;\r資料型態 成員2;\r......\r};\rstruct 結構名稱2\r{\r......\rstruct 結構名稱1 變數名稱;\r}; 結構陣列 宣告 struct 結構名稱 陣列名稱 [長度];\n存取 陣列名稱 [索引值].陣列成員名稱\nstruct 結構名稱\r{\r......\r資料型態 陣列名稱 [個數];\r}; struct 結構名稱 陣列名稱 [個數];\n存取 陣列名稱 [索引值].陣列成員名稱[索引值]\n下圖為建立5個元素的結構陣列 struct student\r{\rchar name[10];\rint score;\r};\rstruct student class1[5]; 容器 vector、map、queue、stack map vs unorder_map map 基礎建立於樹狀(紅黑樹)存取資料，遍歷時會自動排序好鍵(key)，因此在查找與插入為O(log n)。 適合用在大於某個值得最小key等或是區間查詢。\nfind() 找尋某個值，回傳該值。 map-\u0026gt;second 回傳鍵值。 count() 回傳元素有幾個。 unorder_map 基礎建立於雜湊\u0026amp;\u0026amp;沒有順序之差。因此在查找與插入為O(1)，但需要消耗較多記憶體空間。 適合使用大量查詢判斷是否有該值存在、以及鍵值為何。 Key 數量大則很適用使用。\n使用at()如果不存在，會直接out of range; 如果發生碰撞問題會退化O (n) 不允許重複元素 reserve可避免rehash問題，影響執行效率。 vector 動態的容器，每次push_back()、insert，都會重新分配記憶體。\nreserve()分配記憶體。 assign(n,value)，重構並指定數值。 visited.assign(n+1, vector\u0026lt;bool\u0026gt;(m+1, false));(二維靜態) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; v(n);(二維動態) push_back()放入尾端 size()陣列元素的總數 begin()指著第一個元素，end()指著最後元素的下一個 it++ 會保留舊副本; ++ it 則會直接下一個，在map等效率很重視++it empty()回傳是否為空，true or false for(auto it = v.begin(); it!= v.end();++it){\rcout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#39; \u0026#39;;\r} 各種有用的 (auto、auto\u0026amp;、string\u0026hellip;) auto、auto\u0026amp; auto用於複製一份資料。可iterate nums陣列。\nnums[4]={0,1,2,3,4};\rfor(auto x:nums){\rx=0;\r}\r//nums-\u0026gt;0 1 2 3 4 auto\u0026amp; 直接修改值本身\nnums[4]={0,1,2,3,4};\rfor(auto \u0026amp;x:nums){\rx=0;\r}\r//nums-\u0026gt;0 0 0 0 0 string string +=：添加字串\nstring+：字串相加\nat(i)：存取索引值[i]的字元，存取越界會拋出一個例外\nfind()：字串搜尋，回傳字串首個位置。 substr(n,m)：取得子字串，從n開始往印出m個字母。 empty()：回傳是否為空，空則回傳true\nsize()：回傳目前長度\nlength()：回傳目前長度 append()：添加字串\nfor (auto \u0026amp;c : str) { cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }\r} 取得str的地址開始疊代。\n如果使用運算式相加會複製一份，可以使用append or += 提升效率 rotate 將陣列元素往後位移n個，中間begin使前方往後n個元素;反之end使後方往前n個元素。 rotate(v.begin(),v.begin/end(),n) ;#inlcude\u0026lt;algorithm\u0026gt;\nsort vs qsort函式 結論是c++ stl sort一定比c的qsort快 以下為使用方法\nsort 一般陣列 : sort(a,b) 指從a位置排到b位置 ,大到小則在sort(a,b,cmp) cmp中加入 greater\u0026lt;int\u0026gt;()\nvector : sort(v.begin(),v.begin()+n) 也為相同道理，只是stl容器需要使用begin()+n來指定起終點。大到小同理greater\u0026lt;int\u0026gt;() 或是善用反向迭代 sort(v.rbegin(),v.rend())\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rint main(void) {\rint v[6]={2,7,3,1,4,5};\rvector\u0026lt;int\u0026gt; v2={2,7,3,1,4,5};\rsort(v,v+6); sort(v2.begin(),v2.end());\rfor(int i=0;i\u0026lt;6;i++) {\rcout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\r}\rcout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;\rfor(int i=0;i\u0026lt;6;i++) {\rcout\u0026lt;\u0026lt;v2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\r}\rcout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;\r} struct : 多加一個比較函式，看要針對結構哪個排序。 a.score \u0026lt; b.score 回傳true 表示每個a\u0026lt;b，由小到大排，反之大到小。\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\rusing namespace std;\rstruct node {\rstring name;\rint score;\r}s[3];\rbool cmp(node a,node b) {\rreturn a.score \u0026lt; b.score;\r}\rint main(void) {\rs[0].name=\u0026#34;Ken\u0026#34;;s[0].score=70;\rs[1].name=\u0026#34;Yellow\u0026#34;;s[1].score=50;\rs[2].name=\u0026#34;Green\u0026#34;;s[2].score=60;\rfor(auto st: s) {\rcout\u0026lt;\u0026lt;st.name\u0026lt;\u0026lt;\u0026#34; score:\u0026#34;\u0026lt;\u0026lt;st.score\u0026lt;\u0026lt;endl;\r}\rsort(s,s+3,cmp);\rfor(auto st: s) {\rcout\u0026lt;\u0026lt;st.name\u0026lt;\u0026lt;\u0026#34; score:\u0026#34;\u0026lt;\u0026lt;st.score\u0026lt;\u0026lt;endl;\r}\r} qsort 一般陣列： qsort(陣列，數量，記憶體形式，比較函式)。 指向int指向a，a-b為小到大， b-a為大到小。\n#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rint cmp(const void* a,const void* b) {\rreturn (*(int *)a) - (*(int *)b);\r}\rint main(void) {\rint v[5]={3,4,2,1,5};\rfor(auto st: v) {\rcout\u0026lt;\u0026lt;st\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\r}\rcout\u0026lt;\u0026lt;endl;\rqsort(v,5,sizeof(int),cmp);\rfor(auto st: v) {\rcout\u0026lt;\u0026lt;st\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\r}\r} struct : cmp中由int位置改成 struct node(結構名稱)。意思為struct node 指向 a 指向score， a-b為小到大， b-a為大到小。\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rstruct node {\rstring name;\rint score;\r}s[3];\rint cmp(const void* a,const void* b) {\rreturn ((struct node *)a)-\u0026gt;score - ((struct node *)b)-\u0026gt;score;\r}\rint main(void) {\rs[0].name=\u0026#34;Ken\u0026#34;;s[0].score=70;\rs[1].name=\u0026#34;Yellow\u0026#34;;s[1].score=50;\rs[2].name=\u0026#34;Green\u0026#34;;s[2].score=60;\rfor(auto st: s) {\rcout\u0026lt;\u0026lt;st.name\u0026lt;\u0026lt;\u0026#34; score:\u0026#34;\u0026lt;\u0026lt;st.score\u0026lt;\u0026lt;endl;\r}\rqsort(s,3,sizeof(struct node),cmp);\rfor(auto st: s) {\rcout\u0026lt;\u0026lt;st.name\u0026lt;\u0026lt;\u0026#34; score:\u0026#34;\u0026lt;\u0026lt;st.score\u0026lt;\u0026lt;endl;\r}\r} ","permalink":"https://tzuyou.github.io/blog/post-4/","tags":null,"title":"C/C++程式語言_基礎篇"},{"categories":["程式設計"],"contents":" 第一章-HTML HTML基本概念 基本概念\nhr 分頁 br 換行 p 內文 a 標籤 href=\u0026ldquo;連結\u0026rdquo; 雙引號內放入連結 target=\u0026ldquo;black\u0026rdquo; 點擊連結開啟新分頁 連結中的文字或是序列中都可以加上粗體、斜體 序列中也可以安插圖片、連結 常用快捷鍵 Ctrl+/ 快速註解 Ctrl+tab 展開 Alt+右 跳到詞的最尾 Ctrl+D 選取文字， 例如框選h1，h1及/h1裡的h1都會被選取，在更換標題等級時很方便 效果 範例程式碼 \u0026lt;h1\u0026gt;Hell World\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; 內文 \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;https://developer.mozilla.org/zh-TW/docs/Web/HTML\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Html參考\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; HTML基本概念 圖片\u0026amp;清單\n清單分為有序與無序 有序序列-依數字排列下去 無序序列-使用符號排列 也可以在同個序列中同時安插連結及圖片\n有序序列(ol) Ordered List有序清單\nol開始 /ol結束 之後需要清單的開頭與結束，因此寫入li，/li 在此中間及可放入文字\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 範例效果\n範例程式碼\n\u0026lt;h2\u0026gt;有序清單\u0026lt;/h2\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;HTML介紹\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS介紹\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 無序序列(ul) Unordered List無序清單\nul開始 /ul結束 之後需要清單的開頭與結束，因此寫入li，/li 在此中間及可放入文字\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 下圖為在序列中安插圖片與連結\n範例\n範例程式碼\n\u0026lt;h2\u0026gt;無序清單\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; 外果皮 \u0026lt;a href=\u0026#34;https://zh.wikipedia.org/zh-tw/%E6%9E%9C%E5%AE%9E\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;參考\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;https://pic.pimg.tw/salutsalut/1452052299-3537198664.jpg\u0026#34; alt=\u0026#34;\u0026#34; width=200\u0026gt; \u0026lt;/li\u0026gt; 圖片 與上段程式碼一起討論 可在內文或在同一個序列中同時安插圖片及連結\n可以輸入img後Tab展開 img src=\u0026ldquo;放入圖片連結\u0026rdquo; 一般展開後長這樣 \u0026lt;img src=\u0026quot;\u0026quot; alt=\u0026quot;\u0026quot;\u0026gt;\n可在最後加上 width=某數 調整大小，假設調整200 \u0026lt;img src=\u0026quot;\u0026quot; alt=\u0026quot;\u0026quot; width=200\u0026gt;\n範例效果\n範例程式碼\n\u0026lt;h2\u0026gt;無序清單\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; 外果皮 \u0026lt;a href=\u0026#34;https://zh.wikipedia.org/zh-tw/%E6%9E%9C%E5%AE%9E\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;參考\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;https://pic.pimg.tw/salutsalut/1452052299-3537198664.jpg\u0026#34; alt=\u0026#34;\u0026#34; width=200\u0026gt; \u0026lt;/li\u0026gt; ","permalink":"https://tzuyou.github.io/blog/post-3/","tags":null,"title":"HTML簡易教學"},{"categories":["程式設計"],"contents":" Markdown為輕量級標記式語言，編寫的可讀性高，亦讀也亦寫，文章格式大致有下列幾種。\n第一種-標題 共有六種不同大小 標題1 標題2 標題3 標題4 標題5 標題6 第二種-字體 1.粗體 效果長這樣 2.斜體 效果長這樣 3.粗斜體 效果長這樣 4.刪節號 效果長這樣 5.前言 效果就是一個框框圍住，需要前言或是標註資料來源時都可以使用。\n第三種-序列 1.有序序列 可使數字往下自動排列下去，即使開頭都打1.。\n有 序 序 列 2.無序序列 可以使文字往下排列下去，並同時向內縮排，效果如下。\n無 序 序 列 第四種-其他常用功能 1.超連結 可以放置任何的連結，甚至可以放網站內的其他文章，例如常看到的上下篇。\n鏈結可自訂文字 2.shortcodes 假設你想直接分享某些IG、FB、Twitter貼文或者YouTube影片的話，就需要使用到這個功能\n假設我想分享一個關於C#教學影片的話 效果長這樣 3.圖片\u0026amp;表格\u0026amp;圖標 方便你更好呈現文章的內容\n圖片效果如下 表格效果如下 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 個人認為表格不太好用，所以是找範例的，\n左邊有一個手在指的就是圖標，他可以向下縮排(無序序列) 第五種-程式碼區塊 程式碼區塊分了兩種類型 (1) 單行程式碼及 (2) 多行程式碼。 如果你解釋某個程式碼或討論哪個程式碼時就可能需要用到它，因為真的比直接打出來好看多了。\n1.單行程式碼 假設我想只用單一個程式碼下去討論的話，就可以使用這個。 *用Python列印出Hello World舉例 直接打出來的話 print(\u0026ldquo;Hello World\u0026rdquo;) 使用程式碼區塊的話 print(\u0026quot;Hello World\u0026quot;) 2.多行程式碼 同理如果要表示多行的程式碼的話，就可以使用這個。 *這次用Python列印出Hello World以及列印出(a)跟(b)，假設a=1,b=a+1舉例 直接打出來的話 a=1 b=a+1 print(\u0026ldquo;Hello World\u0026rdquo;,a,b) 使用程式碼區塊的話 a=1\rb=a+1\rprint(\u0026#34;Hello World\u0026#34;,a,b) 3.顏色 不是只有單一個顏色，如果在程式碼區塊旁加上其他的程式語言，他就會變成該程式語言的配色。\n以css為例 a=1 b=a+1 print(\u0026#34;Hello World\u0026#34;,a,b) 詳細支援的程式語言可參考此列表 Markdown語法文章介紹到此結束 ","permalink":"https://tzuyou.github.io/blog/post-2/","tags":null,"title":"Markdown程式語法介紹"},{"categories":["程式設計"],"contents":" 以下資料皆擷取至網路，並在每篇底下附上連結! HTML介紹 (HyperText Markup Language)，超文本標記語言 一種建立網頁的標準標記語言，用來組織架構並呈現網頁內容的程式語言，打造出網頁的基礎並常與CSS與JavaScript一起使用在網頁設計。\n擷取資料參考 HTML教學影片推薦 CSS介紹 能幫助HTML變得更漂亮的程式語言! CSS可以控制網頁的外觀(靜態與動態元素)和手機板的外觀。\n擷取資料參考 CSS教學影片推薦 JAVA介紹 JAVA是物件導向(Object-Oriented)程式語言 Java是由C++簡化來的。由於C++要和C完全相容,又很注重效能問題,因此C++算是很複雜的程式語言。Java在設計之初,考量的重點之一就是簡單,因此和C++比起來,不僅更為物件導向,而且比C++容易學習。\n擷取資料參考 JAVA教學影片推薦 C#介紹 C# 廣泛用運在建構行動應用程式、遊戲和 Windows 應用程式。 C#(C Sharp)由Microsoft開發的一種通用的多範式程式設計語言，在.NET Framework上運行。\n擷取資料參考 C#教學影片推薦 ","permalink":"https://tzuyou.github.io/blog/post-1/","tags":null,"title":"程式語言介紹"}]